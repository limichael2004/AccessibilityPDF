import cv2
import dlib
import numpy as np
import time
import math
import os
import json
import tkinter as tk
from tkinter import ttk, messagebox, filedialog
from PIL import Image, ImageTk
import fitz  # PyMuPDF for PDF handling
import threading

# --- Configuration & Default Settings ---
class AppConfig:
    def __init__(self):
        # Gesture Mappings (action name -> function name)
        self.gesture_actions = {
            "look_right": "next_page",
            "look_left": "prev_page",
            "look_up": "zoom_in",
            "look_down": "zoom_out",
            "long_blink": "reset_zoom",
            "smile": None,
            "open_mouth": None,
            "raise_eyebrows": None,
            "right_wink": None,
            "left_wink": None
        }
        
        # Threshold Settings
        self.thresholds = {
            "YAW_THRESHOLD_RIGHT": -30,    # Degrees head needs to turn right
            "YAW_THRESHOLD_LEFT": 30,      # Degrees head needs to turn left
            "PITCH_THRESHOLD_UP": -20,     # Degrees head needs to tilt up
            "PITCH_THRESHOLD_DOWN": 20,    # Degrees head needs to tilt down
            "LONG_BLINK_DURATION": 2.0,    # Seconds eyes must be closed
            "RIGHT_WINK_DURATION": 1.0,    # Seconds right eye must be closed
            "LEFT_WINK_DURATION": 1.0,     # Seconds left eye must be closed
            "SMILE_DURATION": 1.5,         # Seconds smile must be held
            "OPEN_MOUTH_DURATION": 1.5,    # Seconds mouth must be open
            "RAISED_EYEBROWS_DURATION": 1.5, # Seconds eyebrows must be raised
            "ACTION_COOLDOWN": 0.5,        # Cooldown between actions
            "CONTINUOUS_ACTION_INTERVAL": 1.0,  # Time between continuous actions
            "EYE_AR_THRESH": 0.2,          # Eye aspect ratio for blink
            "MOUTH_AR_THRESH": 0.6,        # Mouth aspect ratio for opening
            "SMILE_THRESHOLD": 0.7         # Threshold for smile detection
        }
        
        # Advanced gesture combinations (optional, similar to original)
        self.gesture_combinations = []
        
        # Available Actions (for UI mapping)
        self.available_actions = [
            "next_page",
            "prev_page",
            "zoom_in",
            "zoom_out",
            "reset_zoom",
            "none"  # Option for no action
        ]
        
        # Config file path
        self.config_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pdf_control_config.json")
    
    def save_config(self):
        """Save current configuration to file"""
        config_data = {
            "gesture_actions": self.gesture_actions,
            "thresholds": self.thresholds,
            "gesture_combinations": self.gesture_combinations
        }
        
        try:
            with open(self.config_path, 'w') as f:
                json.dump(config_data, f, indent=4)
            return True
        except Exception as e:
            print(f"Error saving configuration: {e}")
            return False
    
    def load_config(self):
        """Load configuration from file if exists"""
        if not os.path.exists(self.config_path):
            print("No saved configuration found. Using defaults.")
            return False
        
        try:
            with open(self.config_path, 'r') as f:
                config_data = json.load(f)
                
            self.gesture_actions.update(config_data.get("gesture_actions", {}))
            self.thresholds.update(config_data.get("thresholds", {}))
            self.gesture_combinations = config_data.get("gesture_combinations", [])
            return True
        except Exception as e:
            print(f"Error loading configuration: {e}")
            return False

# --- Global Configuration ---
config = AppConfig()

# --- PDF Control Functions ---
class PDFViewer:
    def __init__(self, pdf_path, root):
        self.pdf_path = pdf_path
        self.doc = fitz.open(pdf_path)
        self.current_page = 0
        self.zoom_level = 1.0
        self.root = root
        self.canvas = tk.Canvas(root, bg="white")
        self.canvas.pack(fill=tk.BOTH, expand=True)
        self.img_tk = None
        self.render_page()

    def render_page(self):
        page = self.doc.load_page(self.current_page)
        mat = fitz.Matrix(self.zoom_level, self.zoom_level)
        pix = page.get_pixmap(matrix=mat)
        img = Image.frombytes("RGB", [pix.width, pix.height], pix.samples)
        self.img_tk = ImageTk.PhotoImage(img)
        self.canvas.create_image(0, 0, anchor=tk.NW, image=self.img_tk)

    def next_page(self):
        if self.current_page < len(self.doc) - 1:
            self.current_page += 1
            self.render_page()

    def prev_page(self):
        if self.current_page > 0:
            self.current_page -= 1
            self.render_page()

    def zoom_in(self):
        self.zoom_level *= 1.2
        self.render_page()

    def zoom_out(self):
        self.zoom_level /= 1.2
        self.render_page()

    def reset_zoom(self):
        self.zoom_level = 1.0
        self.render_page()

# Dictionary of available actions for mapping
action_functions = {
    "next_page": lambda viewer: viewer.next_page(),
    "prev_page": lambda viewer: viewer.prev_page(),
    "zoom_in": lambda viewer: viewer.zoom_in(),
    "zoom_out": lambda viewer: viewer.zoom_out(),
    "reset_zoom": lambda viewer: viewer.reset_zoom(),
    "none": lambda viewer: None
}

# --- Configuration UI ---
class ConfigurationUI:
    def __init__(self, master, app_config):
        self.master = master
        self.config = app_config
        self.master.title("PDF Control Configuration")
        self.master.geometry("800x700")
        self.master.resizable(True, True)
        
        self.config.load_config()
        
        self.pdf_path = None
        self.create_widgets()
    
    def create_widgets(self):
        main_frame = ttk.Frame(self.master, padding="20")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        style = ttk.Style()
        style.configure("TLabel", font=("Arial", 11))
        style.configure("TButton", font=("Arial", 11))
        style.configure("TNotebook.Tab", font=("Arial", 11), padding=[10, 5])
        style.configure("Title.TLabel", font=("Arial", 18, "bold"))
        style.configure("Header.TLabel", font=("Arial", 13, "bold"))
        
        title_label = ttk.Label(main_frame, text="Head Gesture PDF Control Configuration", 
                               style="Title.TLabel")
        title_label.pack(pady=(0, 25))
        
        notebook = ttk.Notebook(main_frame)
        notebook.pack(fill=tk.BOTH, expand=True)
        
        # Gesture Mappings Tab
        mappings_frame = ttk.Frame(notebook, padding=15)
        notebook.add(mappings_frame, text="Gesture Mappings")
        
        ttk.Label(mappings_frame, text="Assign Actions to Gestures:", 
                 style="Header.TLabel").pack(anchor=tk.W, pady=(0, 15))
        
        self.gesture_vars = {}
        gesture_display = {
            "look_right": "Look Right",
            "look_left": "Look Left",
            "long_blink": "Long Blink",
            "right_wink": "Right Wink",
            "left_wink": "Left Wink",
            "look_up": "Look Up",
            "look_down": "Look Down",
            "smile": "Smile",
            "open_mouth": "Open Mouth",
            "raise_eyebrows": "Raise Eyebrows"
        }
        
        action_display = {
            "next_page": "Next Page",
            "prev_page": "Previous Page",
            "zoom_in": "Zoom In",
            "zoom_out": "Zoom Out",
            "reset_zoom": "Reset Zoom",
            "none": "No Action"
        }
        
        mapping_frame = ttk.Frame(mappings_frame)
        mapping_frame.pack(fill=tk.X, pady=10)
        
        left_frame = ttk.Frame(mapping_frame)
        left_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 10))
        
        right_frame = ttk.Frame(mapping_frame)
        right_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=(10, 0))
        
        gestures = list(gesture_display.items())
        mid_point = len(gestures) // 2
        
        for i, (gesture_key, gesture_name) in enumerate(gestures[:mid_point]):
            frame = ttk.Frame(left_frame)
            frame.pack(fill=tk.X, pady=8)
            gesture_label = ttk.Label(frame, text=f"{gesture_name}:", width=20)
            gesture_label.pack(side=tk.LEFT, padx=(0, 10))
            current_action = self.config.gesture_actions.get(gesture_key, "none")
            action_var = tk.StringVar(value=action_display.get(current_action, "No Action"))
            self.gesture_vars[gesture_key] = action_var
            dropdown = ttk.Combobox(frame, textvariable=action_var, state="readonly", width=15)
            dropdown['values'] = list(action_display.values())
            dropdown.pack(side=tk.RIGHT, fill=tk.X, expand=True)
            dropdown.bind("<<ComboboxSelected>>", self.make_callback(gesture_key, action_var, action_display))
        
        for i, (gesture_key, gesture_name) in enumerate(gestures[mid_point:]):
            frame = ttk.Frame(right_frame)
            frame.pack(fill=tk.X, pady=8)
            gesture_label = ttk.Label(frame, text=f"{gesture_name}:", width=20)
            gesture_label.pack(side=tk.LEFT, padx=(0, 10))
            current_action = self.config.gesture_actions.get(gesture_key, "none")
            action_var = tk.StringVar(value=action_display.get(current_action, "No Action"))
            self.gesture_vars[gesture_key] = action_var
            dropdown = ttk.Combobox(frame, textvariable=action_var, state="readonly", width=15)
            dropdown['values'] = list(action_display.values())
            dropdown.pack(side=tk.RIGHT, fill=tk.X, expand=True)
            dropdown.bind("<<ComboboxSelected>>", self.make_callback(gesture_key, action_var, action_display))
        
        # PDF File Selection
        ttk.Separator(mappings_frame, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=20)
        ttk.Label(mappings_frame, text="Select PDF File:", style="Header.TLabel").pack(anchor=tk.W, pady=(0, 15))
        select_btn = ttk.Button(mappings_frame, text="Browse PDF", command=self.select_pdf)
        select_btn.pack(anchor=tk.W)
        self.pdf_label = ttk.Label(mappings_frame, text="No PDF selected")
        self.pdf_label.pack(anchor=tk.W, pady=10)
        
        # Thresholds Tab
        thresholds_frame = ttk.Frame(notebook, padding=15)
        notebook.add(thresholds_frame, text="Sensitivity Settings")
        
        ttk.Label(thresholds_frame, text="Adjust Gesture Detection Sensitivity:", 
                 style="Header.TLabel").pack(anchor=tk.W, pady=(0, 15))
        
        self.threshold_vars = {}
        threshold_display = {
            "YAW_THRESHOLD_RIGHT": {"name": "Head Turn Right", "desc": "Degrees to turn right", "min": -90, "max": -15, "resolution": 1},
            "YAW_THRESHOLD_LEFT": {"name": "Head Turn Left", "desc": "Degrees to turn left", "min": 15, "max": 90, "resolution": 1},
            "PITCH_THRESHOLD_UP": {"name": "Head Tilt Up", "desc": "Degrees to tilt up", "min": -45, "max": -5, "resolution": 1},
            "PITCH_THRESHOLD_DOWN": {"name": "Head Tilt Down", "desc": "Degrees to tilt down", "min": 5, "max": 45, "resolution": 1},
            "LONG_BLINK_DURATION": {"name": "Long Blink Duration", "desc": "Seconds for long blink", "min": 0.5, "max": 10, "resolution": 0.5},
            # Add more as needed...
        }
        
        for key, props in threshold_display.items():
            group_frame = ttk.LabelFrame(thresholds_frame, text=props["name"], padding=(10, 5))
            group_frame.pack(fill=tk.X, pady=8, padx=5)
            ttk.Label(group_frame, text=props["desc"], wraplength=500).pack(anchor=tk.W, pady=(0, 5))
            var = tk.DoubleVar(value=self.config.thresholds.get(key, (props["min"] + props["max"]) / 2))
            self.threshold_vars[key] = var
            slider_frame = ttk.Frame(group_frame)
            slider_frame.pack(fill=tk.X, pady=(0, 5))
            ttk.Label(slider_frame, text=str(props["min"])).pack(side=tk.LEFT, padx=(0, 5))
            slider = ttk.Scale(slider_frame, from_=props["min"], to=props["max"], orient="horizontal", variable=var)
            slider.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
            ttk.Label(slider_frame, text=str(props["max"])).pack(side=tk.LEFT, padx=(5, 10))
            value_label = ttk.Label(slider_frame, text=str(var.get()), width=5)
            value_label.pack(side=tk.RIGHT, padx=5)
            slider.config(command=lambda val, k=key, v=var, l=value_label: self.update_threshold_and_label(k, v, l))
        
        # Buttons
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=15)
        save_btn = ttk.Button(button_frame, text="Save & Start", command=self.save_and_start)
        save_btn.pack(side=tk.RIGHT, padx=5)
    
    def make_callback(self, g_key, a_var, action_display):
        def callback(event):
            display_to_func = {v: k for k, v in action_display.items()}
            self.config.gesture_actions[g_key] = display_to_func[a_var.get()]
        return callback
    
    def update_threshold_and_label(self, key, var, label):
        value = round(float(var.get()), 2)
        self.config.thresholds[key] = value
        label.config(text=f"{value}")
    
    def select_pdf(self):
        self.pdf_path = filedialog.askopenfilename(filetypes=[("PDF Files", "*.pdf")])
        if self.pdf_path:
            self.pdf_label.config(text=os.path.basename(self.pdf_path))
    
    def save_and_start(self):
        if not self.pdf_path:
            messagebox.showerror("Error", "Please select a PDF file.")
            return
        self.config.save_config()
        self.master.destroy()
        self.start_app = True

# --- Facial Detection Functions ---
# (Similar to original, omitting for brevity, but include calculate_eye_aspect_ratio, etc.)

# Assume the same process_facial_features, get_head_pose, etc. from the original code.

# --- Main Loop ---
def run_pdf_control(pdf_path):
    # Initialize variables (similar to original)
    # ...

    # Open PDF Viewer Window
    pdf_root = tk.Tk()
    pdf_root.title("PDF Viewer")
    pdf_root.geometry("800x600")
    viewer = PDFViewer(pdf_path, pdf_root)

    # Run facial tracking in a thread
    def facial_tracking_thread():
        cap = cv2.VideoCapture(0)
        detector = dlib.get_frontal_face_detector()
        predictor = dlib.shape_predictor("shape_predictor_68_face_landmarks.dat")
        
        while True:
            ret, frame = cap.read()
            if not ret:
                continue
            # Process frame, detect gestures, execute actions on viewer
            # For example:
            # if gesture == "look_right":
            #     action_functions["next_page"](viewer)
            # ...
            cv2.imshow("Facial Tracking", frame)
            if cv2.waitKey(1) & 0xFF == ord('q'):
                break
        
        cap.release()
        cv2.destroyAllWindows()

    threading.Thread(target=facial_tracking_thread).start()
    pdf_root.mainloop()

# --- Main Function ---
def main():
    root = tk.Tk()
    config_ui = ConfigurationUI(root, config)
    root.mainloop()
    
    if hasattr(config_ui, 'start_app') and config_ui.start_app:
        run_pdf_control(config_ui.pdf_path)

if __name__ == "__main__":
    main()
